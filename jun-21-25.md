# summary of what i did today

- install docker engine in my ubuntu
- add iptables policies that prevent unauthorized access to containers or other services running on your host

## add iptables policies to prevent unauth access to containers on my host

this is like cascade, so we have to write it before docker's to make it take precedence

this is the reference at the time of writing this

https://docs.docker.com/engine/network/packet-filtering-firewalls/#add-iptables-policies-before-dockers-rules

do not use the forward chain, use docker user chain

because forward is too late, we have to get packages before docker does

the way docker works is that it maps virtual container port to host port
so at the time you reach docker-user chain, the mapping was already done
so if you target the container virtual port say 8080, its not there anymore at the docker-user chain since it has been mapped to maybe host 80
so we have to use conntrack to be able to work with host


say packet comes in from outside, someone uses client browser to go to port 80
so from pub ip 80, docker maps that to internal docker virtual ip and port
this happens before docker-user chain
this means by the time we work using docker-user, 80 is not valid no more, the valid one is 8080 port and 172.17.0.2 ip virtual container
so we want a way where we can work this way in docker-user chain
even if it targets host ip and port originally and NOW its rewritten to somewhere else the docker virtual port and ip, consider it!
but by default it would ignore that
to make it consider it we use conntrack
this way we can work using the real port and ip as base of reference, not container virtual values

```bash
sudo iptables -I DOCKER-USER -p tcp -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
sudo iptables -I DOCKER-USER -p tcp -m conntrack --ctorigdst 198.51.100.2 --ctorigdstport 80 -j ACCEPT
```

notice that 198.51.100.2 and 80, we were able to work in real host values

---

know that the way docker works is that
it maps virtual port to host port
so if virtual docker port at 80, can be mapped to be exposed to the world at any real port like 8080
it does that using
iptables
NAT
PAT
masquerading
docker run -p 8080:80 [...]
that means
we want 80 to masquerade as real 8080 on host port

---

this is how to restrict external connection to containers

by default
external source IP
can connect to containers that are published on host port

to allow certain ip to access container
on docker user chain
insert rule
this drop packets from all ip except 192.0.2.2

```bash
iptables -I DOCKER-USER -i ext_if ! -s 192.0.2.2 -j DROP
```

You will need to change ext_if to correspond with your host's actual external interface

there are other ways to filter, by subnet or ip range

---

after reading

I have found out that the doc provides strategies to avoid exposing container to the internet

and there are 2 ways of doing this either you edit the iptable rules

or you make your own custom bridge

here are the refs that talks about making iptable rules
- https://github.com/chaifeng/ufw-docker?tab=readme-ov-file#solving-ufw-and-docker-issues
- https://github.com/moby/moby/issues/4737#issuecomment-419705925

this official docker doc also has ways to make uptable rules but it also have the method to make your own bridge
- https://docs.docker.com/engine/network/packet-filtering-firewalls/#setting-the-default-bind-address-for-containers

i have decided to use the bridge, so that
- local postgres is SAFE against internet
- any user wanting to start this app LOCALLY is confident that the docker dbms is safe from outside world

to do that i just have to add this to the docker compose yaml, that is the thing that is responsible for making the custom bridge

here is a quick example

```yaml
networks:
  mysecurebridge:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.host_binding_ipv4: "127.0.0.1"

services:
  postgres:
    image: postgres
    ports:
      - "5432:5432"
    networks:
      - mysecurebridge
```

or maybe you also can programmatically make it via bash, can also destroy it on cleaup

```bash
echo "üîç Checking if 'mysecurebridge' network exists..."
if ! docker network ls --format '{{.Name}}' | grep -Fxq "mysecurebridge"; then
    echo "üì° Creating 'mysecurebridge' network bound to 127.0.0.1..."
    docker network create \
        --driver bridge \
        -o "com.docker.network.bridge.host_binding_ipv4=127.0.0.1" \
        mysecurebridge
fi
```

user that are not familiar with this wont be disturbed at all
just run and use
custom bridge protects them from outside access by default
custom bridge name is also name spaced so no need to check or alert them for name collision

